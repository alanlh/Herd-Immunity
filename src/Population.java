import java.util.ArrayList;
import java.util.List;
import java.util.Random;


public class Population {
	
	public int[][][] population; // The population of 1,000,000 people, represented by a 3D array, such that (0,0,0) shares a corner with (99, 99, 99).

	// Using lists because the lengths are always changing.
	// Each value in list is a 3-value array, the three values correspond to the coordinates.
	public List<int[]> sickList; // List of all people who are already sick
	public List<int[]> openList; // List of all people who are neither immune nor sick. 
	public List<int[]> tempList; // Temporarily stores people who are about to get sick in a cycle.
	
	public int numberSickened; // Number of healthy people who become sick.
	public int numberImmune; // Number of people who are initially immune. Does not change over time.
	public int initialOpen; // Number of healthy people at the beginning.
	
	public int severity; // Severity level, as inputed by user/generated by program.
	public int contagious; // Contagious level, as inputed by user/generated by program.
	
	public double[] contagionLevels = {0, 0.01, 0.025, 0.5, 0.01, 0.025, 0.05, 0.05, 0.025, 0.1, 0.2}; // Stores probabilities of infection given a certain contagious level.
	// Program has been formatted so that this is the only update required to change the probabilities.
	
	public boolean cleanse = false; // Determines if any currently healthy people are near a sick person.
	
	
	public void generatePopulation(double sickChance, double immuneChance) // Generates a population based off of parameters.
	{	
		
		// Initialize variables and arrays.
		this.population = new int[100][100][100];
		
		this.sickList = new ArrayList<int[]>();
		this.openList = new ArrayList<int[]>();
		
		this.numberImmune = 0; // Initialize so that it can ++ later on
			
		System.out.println("Generating population...");
		for (int i = 0; i < 100; i++)
		{
			for (int j = 0; j < 100; j++) 
			{
				for (int k = 0; k < 100; k++)
				{
					double chance = Math.random();
					
					if (chance < immuneChance)
					{
						this.population[i][j][k] = this.severity + 1; // 11 indicates immune WHEN CHANGING: change sums in Levelx methods
						this.numberImmune ++;
					}
					else if (chance + sickChance > 1)
					{
						this.population[i][j][k] = 1; // 1 indicates sick/infected
						int[] coordinates = {i, j, k};
						this.sickList.add(coordinates);
					}
					else
					{
						this.population[i][j][k] = 0; // 0 indicates not yet sick, but not immune
						int[] coordinates = {i, j, k};
						this.openList.add(coordinates);
					}
					
				}
			}
		}
		
		this.initialOpen = openList.size(); // Keep track of number of initially healthy
		this.numberSickened = 0;

	}
	
	public void simulation()
	{
		/* Contagious Levels:
		 * Level 1 - 3: Touching objects (change of 1 in 1 dimension; 6 cubes); probabilities increase
		 * Level 4 - 6: Edge objects (change of 2 in 2 dimensions; 12 cubes); probabilities increase
		 * Level 7: Corners (Change of 3 in 3 dimensions; 8 cubes)
		 * Level 8 - 10: Two away (Change in 2 in 1 dimension; 6 cubes); probabilities increase
		 */
		
		this.tempList = new ArrayList<int[]>();
		
		int numberofRuns = 0;
		
		while (true) // Each cycle/"run" of simulation is a single loop.
		{

			numberofRuns ++;
			System.out.println("Run " + numberofRuns + ": " + this.openList.size() + " people healthy out of " + this.initialOpen + " remaining.");
			
			this.cleanse = true; // Null hypothesis is that sickness has been contained.
			
			for (int i = 0; i < this.openList.size(); i ++) // Goes through only the openList. 
			{
				determineInfect(openList.get(i)); // Stores all people who will immediately be infected this cycle.
			}
			if (cleanse == true)  
			{
				break; // Indicate there is no changes left
			}
			for (int i = 0; i < sickList.size(); i++) // Those already sick are progressed towards wellness.
			{
				cure(sickList.get(i));
			}
			for (int i = 0; i < this.tempList.size(); i++)
			{
				this.numberSickened ++;
				diagnose(tempList.get(i)); // Officially add a person from templist to the sick list.
			}
			
			this.tempList.clear(); // Clears the temporary list for new cycle.
			
		}
		
	}
	
	
	private void determineInfect(int[] coordinate)
	{	
		int i = coordinate[0];
		int j = coordinate[1];
		int k = coordinate[2];
		
		double resistance = Math.random(); // Resistance on a particular day
		
		if (Level13(i, j, k, resistance)) // Contagion levels 1-3 categorized together: same conditions, only different probabilities.
		{
			this.tempList.add(coordinate); // Add to tempList
			this.openList.remove(coordinate); // Remove from openList
			return;
		}
		else if (this.contagious >= 4 && Level46(i, j, k, resistance))
		{
			this.tempList.add(coordinate);
			this.openList.remove(coordinate);
			return;
		}

		else if (this.contagious >= 7 && Level7(i, j, k, resistance))
		{
			this.tempList.add(coordinate);
			this.openList.remove(coordinate);
			return;
		}
		else if (this.contagious >= 8 && Level810(i,j,k, resistance))
		{
			this.tempList.add(coordinate);
			this.openList.remove(coordinate);
			return;
		}
	}
	
	private boolean Level13(int i, int j, int k, double chance)
	{
		
		int surroundings = // 6 people immediately adjacent.
				  population[(i+1) % 100][j][k]
				+ population[(i+99) % 100][j][k]
				+ population[i][(j+1) % 100][k]
				+ population[i][(j+99) % 100][k]
				+ population[i][j][(k+1) % 100]
				+ population[i][j][(k+99) % 100];
		// First check if there are any sick people nearby.
		// For more accuracy, should run loop through each individual and lower probabilities further, but lazy.
		if (surroundings != 0 && // If equals 0, must mean that everyone is healthy.
				surroundings != (this.severity + 1) * 6) // If all eqauls this.severity + 1, then none are sick and thus able to transmit disease.
		{
			this.cleanse = false; // Indicate that there is still a probability of being infected in the future. 
			if (chance > this.contagionLevels[Math.min(3, this.contagious)])
			{
				return true;
			}
		}
		return false; // Both conditions must be met to return true. 
	}
	
	private boolean Level46(int i, int j, int k, double chance)
	{
		
		int surroundings = // 12 people whose edges are shared
				  population[(i+1) % 100][(j+1) % 100][k]
				+ population[(i+99) % 100][j][(k+1) % 100]
				+ population[i][(j+1) % 100][(k+1) % 100]
				+ population[(i+99) % 100][(j+99) % 100][k]
				+ population[(i+1) % 100][j][(k+1) % 100]
				+ population[i][(j+99) % 100][(k+99) % 100]
				+ population[(i+1) % 100][(j+99) % 100][k]
				+ population[(i+99) % 100][j][(k+99) % 100]
				+ population[i][(j+1) % 100][(k+99) % 100]
				+ population[(i+99) % 100][(j+1) % 100][k]
				+ population[i][(j+99) % 100][(k+1) % 100]
				+ population[(i+1) % 100][j][(k+99) % 100];
		if (surroundings != 0 &&
				surroundings != (this.severity + 1) * 12)
		{
			this.cleanse = false;
			if (chance > this.contagionLevels[Math.min(6, this.contagious)])
			{
				return true;
			}
		}
			return false; 
	}
	
	private boolean Level7(int i, int j, int k, double chance)
	{
		
		int surroundings = // 8 people at the corners
				  population[(i+1) % 100][(j+1) % 100][(k+1) % 100]
				+ population[(i+99) % 100][(j+1) % 100][(k+1) % 100]
				+ population[(i+99) % 100][(j+99) % 100][(k+99) % 100]
				+ population[(i+1) % 100][(j+99) % 100][(k+1) % 100]
				+ population[(i+1) % 100][(j+99) % 100][(k+99) % 100]
				+ population[(i+99) % 100][(j+1) % 100][(k+99) % 100]
				+ population[(i+99) % 100][(j+99) % 100][(k+1) % 100]
				+ population[(i+1) % 100][(j+1) % 100][(k+99) % 100];
		if (surroundings != 0 &&
				surroundings != (this.severity + 1) * 8)
		{
			if (chance > this.contagionLevels[7])
				{
					return true;
				}
		}
			return false; 
	}

	private boolean Level810(int i, int j, int k, double chance)
	{
		
		int surroundings = // Goes 2 in any one direction.
				  population[(i+2) % 100][j][k]
				+ population[(i+98) % 100][j][k]
				+ population[i][(j+2) % 100][k]
				+ population[i][(j+98) % 100][k]
				+ population[i][j][(k+2) % 100]
				+ population[i][j][(k+98) % 100];
		if (surroundings != 0 && 
				surroundings != (this.severity + 1) * 6)
		{
			if (chance > this.contagionLevels[Math.min(8, this.contagious)])
			{
				return true;
			}
		}
			return false; 
	}

	
	private void cure(int[] coordinate)  
	{
		// For all sick people, increase value by 1.
		this.population[coordinate[0]][coordinate[1]][coordinate[2]] ++;
		
		if (this.population[coordinate[0]][coordinate[1]][coordinate[2]] > this.severity) // After increasing it by one, if no longer sick (equals this.severity + 1)
		{
			this.sickList.remove(coordinate); // removes point from sickList
		}
		
	}
	
	private void diagnose(int[] coordinate) // Simple method to go through everyone on tempList and add them to sickList. Already removed from openList in determineInfect.
	{
		this.population[coordinate[0]][coordinate[1]][coordinate[2]] = 1;
		this.sickList.add(coordinate);
	}

}
